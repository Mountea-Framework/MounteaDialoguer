import{aC as v,i as h,A as p,a5 as A,l as E}from"./index-X92JZy_3.js";const q=v((b,i)=>({categories:[],isLoading:!1,maxCategoryDepth:5,maxCategoryNameLength:16,isCategoryNameValid:r=>!(!r||!/^[A-Za-z0-9]+$/.test(r)||r.length>i().maxCategoryNameLength),getRootCategoryId:(r,t)=>{let o=r;const e=new Set;for(;o;){if(e.has(o))return null;e.add(o);const a=t.find(n=>n.id===o);if(!a)return null;if(!a.parentCategoryId)return a.id;o=a.parentCategoryId}return null},isNameUniqueInTree:(r,t,o,e=null)=>{if(!t)return!0;const a=[t],n=new Set;for(;a.length>0;){const s=a.pop();if(!s||n.has(s))continue;n.add(s);const u=o.find(d=>d.id===s);if(u){if(u.id!==e&&u.name===r)return!1;o.filter(d=>d.parentCategoryId===u.id).forEach(d=>a.push(d.id))}}return!0},getCategoryDepth:(r,t)=>{let o=0,e=r;const a=new Set;for(;e;){if(a.has(e))return Number.POSITIVE_INFINITY;a.add(e);const n=t.find(s=>s.id===e);if(!n)break;o+=1,e=n.parentCategoryId||null}return o},getMaxSubtreeDepth:(r,t)=>{const o=new Map;t.forEach(n=>{const s=n.parentCategoryId||null;o.has(s)||o.set(s,[]),o.get(s).push(n.id)});const e=new Set,a=n=>{if(e.has(n))return 0;e.add(n);const s=o.get(n)||[];if(s.length===0)return 1;let u=0;return s.forEach(d=>{u=Math.max(u,a(d))}),1+u};return a(r)},loadCategories:async r=>{b({isLoading:!0});try{const t=await h.categories.where("projectId").equals(r).toArray();b({categories:t,isLoading:!1})}catch(t){console.error("Failed to load categories:",t),p({variant:"error",title:"Failed to Load Categories",description:t.message||"An unexpected error occurred"}),b({isLoading:!1})}},createCategory:async r=>{var t;try{const o=((t=r.name)==null?void 0:t.trim())||"";if(!o)throw new Error("Category name is required");if(!/^[A-Za-z0-9]+$/.test(o))throw new Error("Category name must contain only letters and numbers");if(o.length>i().maxCategoryNameLength)throw new Error(`Category name must be ${i().maxCategoryNameLength} characters or fewer`);const e=await h.categories.where("projectId").equals(r.projectId).toArray(),a=i().maxCategoryDepth;if(r.parentCategoryId){const g=i().getCategoryDepth(r.parentCategoryId,e);if(!Number.isFinite(g)||g+1>a)throw new Error(`Category depth cannot exceed ${a} levels.`)}const s=(r.parentCategoryId?i().getRootCategoryId(r.parentCategoryId,e):null)||null;if(!(s?i().isNameUniqueInTree(r.name,s,e):!e.some(g=>!g.parentCategoryId&&g.name===r.name)))throw new Error("Category name must be unique within its tree.");const d=new Date().toISOString(),c={id:A(),...r,createdAt:d,modifiedAt:d};return await h.categories.add(c),await i().loadCategories(r.projectId),E.getState().schedulePush(r.projectId),p({variant:"success",title:"Category Created",description:`${r.name} has been created successfully`}),c}catch(o){throw console.error("Error creating category:",o),p({variant:"error",title:"Failed to Create Category",description:o.message||"An unexpected error occurred"}),o}},updateCategory:async(r,t)=>{var o;try{const e=await h.categories.get(r);if(!e)throw new Error("Category not found");const a=((o=t.name??e.name)==null?void 0:o.trim())||"";if(!a)throw new Error("Category name is required");if(!/^[A-Za-z0-9]+$/.test(a))throw new Error("Category name must contain only letters and numbers");if(a.length>i().maxCategoryNameLength)throw new Error(`Category name must be ${i().maxCategoryNameLength} characters or fewer`);const n=await h.categories.where("projectId").equals(e.projectId).toArray(),s=i().maxCategoryDepth,u=t.parentCategoryId===void 0?e.parentCategoryId:t.parentCategoryId,d=t.name===void 0?e.name:t.name,w=u?i().getCategoryDepth(u,n):0,c=i().getMaxSubtreeDepth(e.id,n),g=w+c;if(!Number.isFinite(w)||g>s)throw new Error(`Category depth cannot exceed ${s} levels.`);const f=(u?i().getRootCategoryId(u,n):null)||e.id;if(!i().isNameUniqueInTree(d,f,n,e.id))throw new Error("Category name must be unique within its tree.");if(!u&&n.find(l=>l.id!==e.id&&!l.parentCategoryId&&l.name===d))throw new Error("Category name must be unique within its tree.");const y={...e,...t,modifiedAt:new Date().toISOString()};return await h.categories.update(r,y),await i().loadCategories(e.projectId),E.getState().schedulePush(e.projectId),p({variant:"success",title:"Category Updated",description:"Category has been updated successfully"}),y}catch(e){throw console.error("Error updating category:",e),p({variant:"error",title:"Failed to Update Category",description:e.message||"An unexpected error occurred"}),e}},deleteCategory:async r=>{try{const t=await h.categories.get(r);if(!t)throw new Error("Category not found");await h.categories.delete(r),await i().loadCategories(t.projectId),E.getState().schedulePush(t.projectId),p({variant:"success",title:"Category Deleted",description:"Category has been deleted"})}catch(t){throw console.error("Error deleting category:",t),p({variant:"error",title:"Failed to Delete Category",description:t.message||"An unexpected error occurred"}),t}},importCategories:async(r,t)=>{try{const o=new Date().toISOString(),e=await h.categories.where("projectId").equals(r).toArray(),a=i().maxCategoryDepth,n=new Map,s=c=>(n.has(c)||n.set(c,new Set),n.get(c));e.filter(c=>!c.parentCategoryId).forEach(c=>{const g=s(c.name);g.add(c.name),e.forEach(m=>{i().getRootCategoryId(m.id,e)===c.id&&g.add(m.name)})});const d=new Map;e.forEach(c=>{const g=i().buildCategoryPath(c.id,e);d.set(g,c.id)});const w=[];for(const c of t){const g=c.fullPath||c.name;if(d.has(g))continue;const m=g.split(".");if(m.length>a)throw new Error(`Category depth cannot exceed ${a} levels.`);const f=m[0],S=s(f);for(let l=0;l<m.length;l++){const C=m[l];if(!/^[A-Za-z0-9]+$/.test(C))throw new Error("Category name must contain only letters and numbers");if(C.length>i().maxCategoryNameLength)throw new Error(`Category name must be ${i().maxCategoryNameLength} characters or fewer`);if(S.has(C)&&!(l===0&&C===f))throw new Error("Category name must be unique within its tree.");S.add(C)}let y="",I=null;for(let l=0;l<m.length;l++){const C=m[l];if(y=y?`${y}.${C}`:C,d.has(y)){I=d.get(y);continue}const x={id:A(),name:C,parentCategoryId:I,projectId:r,createdAt:o,modifiedAt:o};await h.categories.add(x),d.set(y,x.id),w.push(x),I=x.id}}return await i().loadCategories(r),E.getState().schedulePush(r),p({variant:"success",title:"Categories Imported",description:`${w.length} categories have been imported`}),w}catch(o){throw console.error("Error importing categories:",o),p({variant:"error",title:"Failed to Import Categories",description:o.message||"An unexpected error occurred"}),o}},buildCategoryPath:(r,t)=>{const o=[];let e=t.find(a=>a.id===r);for(;e;)o.unshift(e.name),e=t.find(a=>a.id===e.parentCategoryId);return o.join(".")},exportCategories:async r=>{try{const t=await h.categories.where("projectId").equals(r).toArray();return t.map(o=>({name:o.name,fullPath:i().buildCategoryPath(o.id,t)}))}catch(t){throw console.error("Error exporting categories:",t),p({variant:"error",title:"Failed to Export Categories",description:t.message||"An unexpected error occurred"}),t}}}));export{q as useCategoryStore};
